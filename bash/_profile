# TODO: review this file
# base-files version 4.2-3 (copied from cygwin and modified extensively)
#
# To the extent possible under law, the author(s) have dedicated all 
# copyright and related and neighboring rights to this software to the 
# public domain worldwide. This software is distributed without any warranty. 
# You should have received a copy of the CC0 Public Domain Dedication along 
# with this software. 
# If not, see <http://creativecommons.org/publicdomain/zero/1.0/>. 
#

# $DOTFILES_DIR/bash/_profile: sourced by ~/.bash_profile in bash(1) for login shells.

# Common .bash_profile file

# if not running an interactive shell, return
[ -z "$PS1" ] && return

[ -z "$DEBUG_DOTFILES" ] || echo "Debugging dotfiles"

_PROFILE_BEING_SOURCED=yes

# Comment out the following to silence the statement printed each time a file is sourced
VERBOSE_SOURCING=basic

verbose-file-entry() { echo "->$2$(basename $1)" && shift && shift && [ $# -gt 0 ] && echo "$@"; }
verbose-file-exit()  { echo "<-$2$(basename $1)" && shift && shift && [ $# -gt 0 ] && echo "$@"; }

basic-file-entry() { echo "->$2$(basename $1)"; }
basic-file-exit()  { echo "<-$2$(basename $1)"; }

quiet-file-entry() { true; }
quiet-file-exit()  { true; }

# Update the OS variable
case $(uname -s) in
	Darwin)  [ "$OS" != "*OSX?"       ] && OS="$OS (OSX)"            ;;
	MINGW*)  [ "$OS" != "*Bash?"      ] && OS="$OS (MinGW/Git Bash)" ;;
	CYGWIN*) [ "$OS" != "*Cygwin?"    ] && OS="$OS (Cygwin)"         ;;
	*)       [ "$OS" != "*$(osname)?" ] && OS="$OS ($osname)"        ;;
esac
export OS
echo "Detected OS = ${OS}"

# Resolve DOTFILES_DIR (assuming ~/.dotfiles on distros without readlink and/or $BASH_SOURCE/$0)
READLINK=$((which greadlink || which readlink) 2> /dev/null)
CURRENT_SCRIPT=$BASH_SOURCE
if [[ -n $CURRENT_SCRIPT && -x "$READLINK" ]]; then
	SCRIPT_PATH=$($READLINK -f "$CURRENT_SCRIPT")
	DOTFILES_DIR=$(dirname "$(dirname "$SCRIPT_PATH")")
elif [ -d "$HOME/.dotfiles" ]; then
	DOTFILES_DIR="$HOME/.dotfiles"
else
	echo "Unable to find dotfiles, exiting."
	return # `exit 1` would quit the shell itself
fi
unset READLINK CURRENT_SCRIPT SCRIPT_PATH
export DOTFILES_DIR
echo "Detected DOTFILES_DIR = ${DOTFILES_DIR} ($BASH_SOURCE)"


# source dotfiles from the system folder (alias must be first)
for dotfile in $(echo "$DOTFILES_DIR/system/{alias,function,function_*,path,env,completion,grep,prompt,custom,*}" | uniq); do
	case "$dotfile" in 
		*~)             ;;
		*.bak)          ;;
		*.txt)          ;;
		*.sh)           ;;
		*dir_colors)
			if is-supported "[ -l . ]"; then
				[ -f "$HOME/.dir_colors" || -l "$HOME/.dir_colors" ] || ln -s "$dotfile" "$HOME/.dir_colors"
			else
				[ -f "$HOME/.dir_colors" ] || cp "$dotfile" "$HOME/.dir_colors"
			fi
			;;
		*)
			[ -f "$dotfile" ] && [ -r "$dotfile" ] && echo "Attempting to source $dotfile" && pushd "$DOTFILES_DIR/system" && . "$dotfile" && popd ;;
	esac
done
unset dotfile

# source dotfiles from the bash folder
for dotfile in $(echo "$DOTFILES_DIR"/bash/{functions*,aliases*,path,*} | uniq); do
	case "$dotfile" in 
		*_profile)      ;;
		*~)             ;;
		*.bak)          ;;
		*.txt)          ;;
		*.sh)           ;;
		*bash/global.*) ;;
		*)
			[ -f "$dotfile" ] && [ -r "$dotfile" ] && echo "Attempting to source $dotfile" && pushd "$DOTFILES_DIR/bash" && . "$dotfile" && popd ;;
  esac
done
unset dotfile

# source dotfiles from the git folder
for dotfile in $(echo "$DOTFILES_DIR"/git/{functions*,aliases*,path*,*} | uniq); do
	case "$dotfile" in 
		*~)             ;;
		*.bak)          ;;
		*.txt)          ;;
		*.sh)           ;;
		*git/global.*)  ;;
		*)
			[ -f "$dotfile" ] && [ -r "$dotfile" ] && echo "Attempting to source $dotfile" && pushd "$DOTFILES_DIR/git" && . "$dotfile" && popd ;;
	esac
done
unset dotfile

echo "bash/_profile is finished loading, but implementation is incomplete"

unset _PROFILE_BEING_SOURCED
return
#incomplete



# Load the shell dotfiles, and then some:
# any file called ~/.bash*.user can be used to extend this file locally without being checked into git
for dotfile in ~/.bash*.user; do
  . "$dotfile"
done
unset dotfile;


if [ 1 -ne 0 ]; then

# Enable tab completion for `g` by marking it as an alias for `git`
if type _git &> /dev/null && [ -f /usr/local/etc/bash_completion.d/git-completion.bash ]; then
	complete -o default -o nospace -F _git g;
fi;

# Add tab completion for SSH hostnames based on ~/.ssh/config, ignoring wildcards
[ -e "$HOME/.ssh/config" ] && complete -o "default" -o "nospace" -W "$(grep "^Host" ~/.ssh/config | grep -v "[?*]" | cut -d " " -f2- | tr ' ' '\n')" scp sftp ssh;

# Add tab completion for `defaults read|write NSGlobalDomain`
# You could just use `-g` instead, but I like being explicit
complete -W "NSGlobalDomain" defaults;

# Add `killall` tab completion for common apps
complete -o "nospace" -W "Contacts Calendar Dock Finder Mail Safari iTunes SystemUIServer Terminal Twitter" killall;

fi # if [ 1 -ne 0 ]; then

unset _PROFILE_BEING_SOURCED

#EOF
